---
title:  "Greedy 문제"
excerpt: "코딩 테스트 단골 문제인 Greedy 문제들을 풀어보았습니다."
date: 2020-08-28 01:15:00 
toc: true
toc_sticky: true
toc_label: "목차"
comments: true

categories:
  - codingtest

tags:
  - greedy
  - codingtest

sidebar:
​    nav: "docs"
---







### Intro

- 나동빈님의 '이것이 취업을 위한 코딩 테스트다' 책을 보며 풀어본 그리디 문제입니다.

<br>

#### 큰 수의 법칙

##### 문제 설명

- **큰 수의 법칙**
  - 배열이 다양한 수로 이루어졌을 때, 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙입니다.
  - 그러나, 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수는 없습니다.
- 예시
  - 배열: [7, 6, 7, 6, 5] 이 존재하고, 
  - K가 3, M이 6이라면, 
  - 7 + 7 + 7 + 6 + 7 + 7 = 41이 됩니다.
- 입력 예시
  - N (배열의 크기), M (숫자가 더해지는 횟수), K (연속해서 더할 수 있는 횟수)
  - 배열



##### 문제 접근 

- 위 방식은 전형적인 알고리즘 문제로 머릿속에 떠오르는 아이디어를 이용합니다.
- 이를 위해서는 가장 큰 숫자와 두 번째로 큰 숫자를 찾습니다.
- 이를 위해 K 번 가장 큰 숫자를 더하고, 그 이후 1번만 두 번째로 큰 숫자를 더하고 이가 반복되는 형태가 됩니다.



##### 문제 답안

- ```python
  N, M, K = map(int, input().split())
  
  arr = list(map(int, input().split()))
  
  # 정렬하기
  arr.sort()
  
  # 가장 큰 수
  largest = arr[-1]
  
  # 두 번째로 큰 수
  second = arr[-2]
  
  result = 0
  # 가장 큰 수가 더해지는 횟수 계산 
  result += M // K * K * largest
  # 두번째로 큰 수 더하기 
  result += M % K * second
  
  print(result)
  ```

<br>

#### 숫자 카드 게임

##### 문제 설명

- 여러 개의 숫자 카드 중에서 가장 높은 숫자가 쓰인 카드를 한 장을 뽑는 형태이다.
- 카드는 N (행) * M (열) 형태로 놓여있다.
- 먼저 뽑고자 하는 '행'을 선택한다.
- 그 다음 선택된 행에 포함된 카드들 중 **가장 숫자가 낮은** 카드를 뽑는다.
- 그렇기 때문에 처음 카드를 골라낼 행을 선택 시, 이후에 해당 행에서 가장 숫자가 낮은 카드를 뽑을 것을 고려하여 <u>최종적으로 가장 높은 숫자의 카드</u>를 뽑을 수 있도록 전략을 세운다.
- 입력 예시
  - N M
  - N개의 줄에 걸쳐 각 카드에 적힌 숫자가 주어진다.



##### 문제 접근

- 문제에서 가장 중요하게 생각하는 부분은, 각 행마다 가장 낮은 숫자를 찾고, 그 중 가장 큰 숫자를 찾으면 되는 것이다.



##### 문제 답안

- ```python
  N, M = map(int, input().split())
  arr = [list(map(int, input().split())) for _ in range(N)]
  
  result = 0
  
  for i in range(N):
      # 해당 행의 minimum 값을 저장한다.
      temp_min = min(arr[i])
  
      # 이전 최소값과 현재 행의 최소값을 비교해 최대값을 구한다.
      result = max(result, temp_min)
  
  print(result)
  ```

  

#### 1이 될 때 까지

##### 문제 설명

- 어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행한다.
- 단 2번째 연산은 N이 K로 나누어 떨어질 때만 선택이 가능하다.
  - 1. N에서 1을 뺀다
    2. N을 K로 나눈다.
- 그렇다면 N을 1로 만드는 최소 횟수는? 
- 입력
  - N, K (예시: 25, 5)
- 출력
  - 최소 횟수 (예시: 2)

##### 문제 접근

- N을 K로 최대한 많이 나눠야 숫자를 작게 만들 수 있다.
- N이 K로 나뉠 수 있도록 만들고, 그 이후에 1을 빼는 연산을 한다.

##### 문제 답안 

- ```python
  n, k = map(int, input().split())
  answer = 0
  
  while n >= k:
      # n이 k로 한 번에 딱 나누어 떨어지는 수가 될 때 까지 1을 빼기
      target = (n // k) * k 
  
      # 한 번에 안떨어진다면 빼야 하는 횟수! 
      answer += (n - target)
      n = target
  
      # K로 나누기
      answer += 1
      n //= k
  
  answer += (n-1)
  print(answer)
  ```

  

